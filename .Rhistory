## 4. Get the value of the inverse of the matrix
## Calculate and Cache inverse of matrix x
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function (y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list (set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Compute the inverse of matrix x.
## If the inverse has already been calculated, return the
## inverse from the cache.  Otherwise calculate inverse
## and update cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
cm <- makeCacheMatrix(x)
inv <- cm$getinverse()
if (!is.null(inv)) {
message ("getting cached data")
return(inv)    ## return inverse from cache
}
data <- cm$get()
inv <- solve(data, ...)
cm$setinverse(inv)
inv                     ## calculate and return inverse
}
cacheSolve(p1)
cacheSolve(p1)
## Second R Programming Assignment
## These functions caches the result of a matrix inverse computation
## which can be a time consuming computation.  In this way once an inverse is
## computed it can be re-used in future computations without the need to
## recalculate
## The two function swork together to create a special object that stores a matrix
## and caches its inverse
## The first function makeCacheMatrix, creates a list containing functions that
## 1. Set the value of the matrix
## 2. Get the value of the matrix
## 3. Set the value of the inverse of the matrix
## 4. Get the value of the inverse of the matrix
## Calculate and Cache inverse of matrix x
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function (y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list (set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Compute the inverse of matrix x.
## If the inverse has already been calculated, return the
## inverse from the cache.  Otherwise calculate inverse
## and update cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
my_inv <- NULL
cm <- makeCacheMatrix(x)
my_inv <- cm$getinverse()
if (!is.null(my_inv)) {
message ("getting cached data")
return(my_inv)    ## return inverse from cache
}
data <- cm$get()
inv <- solve(data, ...)
cm$setinverse(inv)
inv                     ## calculate and return inverse
}
cacheSolve(p1)
cacheSolve(p1)
cacheSolve(p1)
cacheSolve(p2)
cacheSolve(p2)
## Second R Programming Assignment
## These functions caches the result of a matrix inverse computation
## which can be a time consuming computation.  In this way once an inverse is
## computed it can be re-used in future computations without the need to
## recalculate
## The two function swork together to create a special object that stores a matrix
## and caches its inverse
## The first function makeCacheMatrix, creates a list containing functions that
## 1. Set the value of the matrix
## 2. Get the value of the matrix
## 3. Set the value of the inverse of the matrix
## 4. Get the value of the inverse of the matrix
## Calculate and Cache inverse of matrix x
makeCacheMatrix <- function(x = matrix()) {
## inv <<- NULL
set <- function (y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list (set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Compute the inverse of matrix x.
## If the inverse has already been calculated, return the
## inverse from the cache.  Otherwise calculate inverse
## and update cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
my_inv <- NULL
cm <- makeCacheMatrix(x)
my_inv <- cm$getinverse()
if (!is.null(my_inv)) {
message ("getting cached data")
return(my_inv)    ## return inverse from cache
}
data <- cm$get()
inv <- solve(data, ...)
cm$setinverse(inv)
inv                     ## calculate and return inverse
}
cacheSolve(p2)
## Second R Programming Assignment
## These functions caches the result of a matrix inverse computation
## which can be a time consuming computation.  In this way once an inverse is
## computed it can be re-used in future computations without the need to
## recalculate
## The two function swork together to create a special object that stores a matrix
## and caches its inverse
## The first function makeCacheMatrix, creates a list containing functions that
## 1. Set the value of the matrix
## 2. Get the value of the matrix
## 3. Set the value of the inverse of the matrix
## 4. Get the value of the inverse of the matrix
## Calculate and Cache inverse of matrix x
makeCacheMatrix <- function(x = matrix()) {
## inv <<- NULL
set <- function (y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list (set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Compute the inverse of matrix x.
## If the inverse has already been calculated, return the
## inverse from the cache.  Otherwise calculate inverse
## and update cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
my_inv <- NULL
inv <<- NULL
cm <- makeCacheMatrix(x)
my_inv <- cm$getinverse()
if (!is.null(my_inv)) {
message ("getting cached data")
return(my_inv)    ## return inverse from cache
}
data <- cm$get()
inv <- solve(data, ...)
cm$setinverse(inv)
inv                     ## calculate and return inverse
}
cacheSolve(p2)
cacheSolve(p2)
## Second R Programming Assignment
## These functions caches the result of a matrix inverse computation
## which can be a time consuming computation.  In this way once an inverse is
## computed it can be re-used in future computations without the need to
## recalculate
## The two function swork together to create a special object that stores a matrix
## and caches its inverse
## The first function makeCacheMatrix, creates a list containing functions that
## 1. Set the value of the matrix
## 2. Get the value of the matrix
## 3. Set the value of the inverse of the matrix
## 4. Get the value of the inverse of the matrix
## Calculate and Cache inverse of matrix x
makeCacheMatrix <- function(x = matrix()) {
## inv <<- NULL
set <- function (y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list (set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Compute the inverse of matrix x.
## If the inverse has already been calculated, return the
## inverse from the cache.  Otherwise calculate inverse
## and update cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
my_inv <- NULL
## inv <<- NULL
cm <- makeCacheMatrix(x)
my_inv <- cm$getinverse()
if (!is.null(my_inv)) {
message ("getting cached data")
return(my_inv)    ## return inverse from cache
}
data <- cm$get()
inv <- solve(data, ...)
cm$setinverse(inv)
inv                     ## calculate and return inverse
}
cacheSolve(p2)
cacheSolve(p1)
cacheSolve(p1)
## Second R Programming Assignment
## These functions caches the result of a matrix inverse computation
## which can be a time consuming computation.  In this way once an inverse is
## computed it can be re-used in future computations without the need to
## recalculate
## The two function swork together to create a special object that stores a matrix
## and caches its inverse
## The first function makeCacheMatrix, creates a list containing functions that
## 1. Set the value of the matrix
## 2. Get the value of the matrix
## 3. Set the value of the inverse of the matrix
## 4. Get the value of the inverse of the matrix
## Calculate and Cache inverse of matrix x
makeCacheMatrix <- function(x = matrix()) {
## inv <<- NULL
set <- function (y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list (set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Compute the inverse of matrix x.
## If the inverse has already been calculated, return the
## inverse from the cache.  Otherwise calculate inverse
## and update cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
my_inv <- NULL
if (!exists(inv)) {
inv <<- NULL
}
cm <- makeCacheMatrix(x)
my_inv <- cm$getinverse()
if (!is.null(my_inv)) {
message ("getting cached data")
return(my_inv)    ## return inverse from cache
}
data <- cm$get()
inv <- solve(data, ...)
cm$setinverse(inv)
inv                     ## calculate and return inverse
}
p1 <- matrix(c(1,2,3,4),2,2)
cacheSolve(p1)
## Second R Programming Assignment
## These functions caches the result of a matrix inverse computation
## which can be a time consuming computation.  In this way once an inverse is
## computed it can be re-used in future computations without the need to
## recalculate
## The two function swork together to create a special object that stores a matrix
## and caches its inverse
## The first function makeCacheMatrix, creates a list containing functions that
## 1. Set the value of the matrix
## 2. Get the value of the matrix
## 3. Set the value of the inverse of the matrix
## 4. Get the value of the inverse of the matrix
## Calculate and Cache inverse of matrix x
makeCacheMatrix <- function(x = matrix()) {
## inv <<- NULL
set <- function (y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list (set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Compute the inverse of matrix x.
## If the inverse has already been calculated, return the
## inverse from the cache.  Otherwise calculate inverse
## and update cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
my_inv <- NULL
if (!exists("inv")) {
inv <<- NULL
}
cm <- makeCacheMatrix(x)
my_inv <- cm$getinverse()
if (!is.null(my_inv)) {
message ("getting cached data")
return(my_inv)    ## return inverse from cache
}
data <- cm$get()
inv <- solve(data, ...)
cm$setinverse(inv)
inv                     ## calculate and return inverse
}
cacheSolve(p1)
cacheSolve(p1)
## Second R Programming Assignment
## These functions caches the result of a matrix inverse computation
## which can be a time consuming computation.  In this way once an inverse is
## computed it can be re-used in future computations without the need to
## recalculate
## The two function swork together to create a special object that stores a matrix
## and caches its inverse
## The first function makeCacheMatrix, creates a list containing functions that
## 1. Set the value of the matrix
## 2. Get the value of the matrix
## 3. Set the value of the inverse of the matrix
## 4. Get the value of the inverse of the matrix
## Calculate and Cache inverse of matrix x
makeCacheMatrix <- function(x = matrix()) {
## inv <<- NULL
set <- function (y) {
x <<- y
inv <<- NULL
}
get <- function() x
setinverse <- function(solve) inv <<- solve
getinverse <- function() inv
list (set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Compute the inverse of matrix x.
## If the inverse has already been calculated, return the
## inverse from the cache.  Otherwise calculate inverse
## and update cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
my_inv <- NULL
## if this is the first time the function is run
## initialize key variables
if (!exists("inv")) {
inv <<- NULL
}
if (!exists("prev_x")) {
prev_x <<- NULL
}
cm <- makeCacheMatrix(x)
## check if matrix has changed
if (identical(x, prev_x)) {
my_inv <- cm$getinverse()
}
if (!is.null(my_inv)) {
message ("getting cached data")
return(my_inv)    ## return inverse from cache
}
## new matrix - cache data
prev_x <<- x
data <- cm$get()
inv <- solve(data, ...)
cm$setinverse(inv)
inv                     ## calculate and return inverse
}
cacheSolve(p1)
cacheSolve(p1)
cacheSolve(p1)
p2 <- matrix(c(2,3,3,4),2,2)
cacheSolve(p2)
cacheSolve(p2)
cacheSolve(p1)
cacheSolve(p1)
p3 <- matrix (c(1,0,5,2,1,6,3,4,0),3,3)
p3
cacheSolve(p3)
cacheSolve(p3)
cacheSolve(p2)
cacheSolve(p2)
p1 %*% cacheSolve(p1)
p1 %*% cacheSolve(p1)
p2 %*% cacheSolve(p2)
p2 %*% cacheSolve(p2)
cacheSolve(p2) %*% cacheSolve(p1)
cacheSolve(p1)
makeCacheMatrix <- function(x = matrix()) {
s <- NULL
set <- function(y) {
x <<- y
s <<- NULL
}
get <- function() x
setsolve <- function(solve) s <<- solve
getsolve <- function() s
list(set = set, get = get,
setsolve = setsolve,
getsolve = getsolve)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
s <- x$getsolve()
if(!is.null(s)) {
message("getting cached data")
return(s)
}
data <- x$get()
s <- solve(data)
x$setsolve(s)
s
}
p1 <- matrix (c(1,2,3,4), 2, 2)
cacheSolve(p1)
library(datasets)
with (airquality, plot(Wind, Ozone))
title(main="Ozone and Wind in New York City")  ## Add a title
with(airquality, plot(Wind, Ozone, main="Ozone and Wind in New York City"))
with(subset(airquality,Month==5),points(Wind, Ozone, col=blue))
with(subset(airquality,Month==5),points(Wind, Ozone, col="blue"))
with(airquality, plot(Wind, Ozone, main="Ozone and Wind in New York City"), type="n")
pchshow
pchshow()
pchShow
pchShow()
points()
points
example(points)
## plot3.R
## Outline of Project
##      Download the zip file
##      Unzip the specific data file in question
##      Read in the data pertaining to the 2 days
##      Create the plots as shown
## Assumes you are in your working directory
install.packages("downloader")
library(downloader)
## Download the zip file if data file not already in working directory
datafile <- "household_power_consumption.txt"
if (!file.exists(datafile)) {
url <- "https://d396qusza40orc.cloudfront.net/exdata%2Fdata%2Fhousehold_power_consumption.zip"
destfile <- "household_power_consumption.zip"
download(url, destfile, mode = "wb")
## unzip the file
unzip(destfile)
}
## read in the header
header <- as.vector(read.table(datafile, sep=";", nrows=1))
## read in the data file - records for 2007-02-01 and 2007-02-02
df <- read.table(datafile, sep = ";", na.strings="?", skip=66637, nrows=2880)
h1 <- NULL
for (i in 1:9) { h1 <- c(h1, as.character(header[[i]]))}
colnames(df) <- h1  # set column names
## Plot 3
df$time <- strptime(paste(df$Date, df$Time), "%d/%m/%Y %H:%M:%S")
plot(df$time, df$Sub_metering_1, xlab="", ylab="Energy sub metering", type="l")
lines(df$time, df$Sub_metering_2, col="red")
lines(df$time, df$Sub_metering_3, col="blue")
legend("topright", legend=c("Sub_metering_1","Sub_metering_2","Sub_metering_3"), lty=1, col=c("black", "red", "blue"))
## Save plot to png
dev.copy(png, file="plot3.png", width=480, height=480, units="px")
dev.off()
setwd("../datasicencecoursera/")
setwd("../datasciencecoursera/")
dir()
setwd("ExData_Plotting1")
dir()
## plot3.R
## Outline of Project
##      Download the zip file
##      Unzip the specific data file in question
##      Read in the data pertaining to the 2 days
##      Create the plots as shown
## Assumes you are in your working directory
install.packages("downloader")
library(downloader)
## Download the zip file if data file not already in working directory
datafile <- "household_power_consumption.txt"
if (!file.exists(datafile)) {
url <- "https://d396qusza40orc.cloudfront.net/exdata%2Fdata%2Fhousehold_power_consumption.zip"
destfile <- "household_power_consumption.zip"
download(url, destfile, mode = "wb")
## unzip the file
unzip(destfile)
}
## read in the header
header <- as.vector(read.table(datafile, sep=";", nrows=1))
## read in the data file - records for 2007-02-01 and 2007-02-02
df <- read.table(datafile, sep = ";", na.strings="?", skip=66637, nrows=2880)
h1 <- NULL
for (i in 1:9) { h1 <- c(h1, as.character(header[[i]]))}
colnames(df) <- h1  # set column names
## Plot 3
df$time <- strptime(paste(df$Date, df$Time), "%d/%m/%Y %H:%M:%S")
plot(df$time, df$Sub_metering_1, xlab="", ylab="Energy sub metering", type="l")
lines(df$time, df$Sub_metering_2, col="red")
lines(df$time, df$Sub_metering_3, col="blue")
legend("topright", legend=c("Sub_metering_1","Sub_metering_2","Sub_metering_3"), lty=1, col=c("black", "red", "blue"))
## Save plot to png
dev.copy(png, file="plot3.png", width=480, height=480, units="px")
dev.off()
